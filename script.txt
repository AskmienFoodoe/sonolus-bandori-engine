//
// Bandori Engine
// For Sonolus 0.3.4
//
// A recreation of BanG Dream! Girls Band Party engine
// By Burrito
//



// Note Class

IsNoteHeadOnScreen:LessOr(Subtract(NoteHeadTime Time) NoteScreenTime)
IsNoteTailOnScreen:LessOr(Subtract(NoteTailTime Time) NoteScreenTime)

InitNoteHead:Execute(
    Set(EntityMemory *NoteHeadX Multiply(LaneWidth NoteHeadLane))
    Set(EntityMemory *NoteHeadX1 Subtract(NoteHeadX HalfNoteWidth))
    Set(EntityMemory *NoteHeadX2 Add(NoteHeadX HalfNoteWidth))
)
InitNoteTail:Execute(
    Set(EntityMemory *NoteTailX Multiply(LaneWidth NoteTailLane))
    Set(EntityMemory *NoteTailX1 Subtract(NoteTailX HalfNoteWidth))
    Set(EntityMemory *NoteTailX2 Add(NoteTailX HalfNoteWidth))
)
InitSimLine:And(
    SimLine
    NoteSimLineIndex
    Spawn(10 Index NoteSimLineIndex)
)

InitAutoNormal:And(
    Auto
    Execute(
        PlayScheduled(EffectPerfect NoteTailTime MinEffectTime)
        Set(EntityInput *Judgment JudgmentPerfect)
    )
)
InitAutoFlick:And(
    Auto
    Execute(
        PlayScheduled(EffectFlick NoteTailTime MinEffectTime)
        Set(EntityInput *Judgment JudgmentPerfect)
    )
)

IsNoteTailInGoodWindow:LessOr(Subtract(NoteTailTime Subtract(Time InputOffset)) GoodWindow)

IsTouchY:LessOr(TempTouchY JudgeYMax)
IsTouchXInTailLane:And(
    GreaterOr(TempTouchX Subtract(NoteTailX LaneWidth))
    LessOr(TempTouchX Add(NoteTailX LaneWidth))
)

ProcessTouchHead:And(
    Not(InputState)
    If(
        NoteHeadInputSuccess
        And(
            Equal(TempTouchID NoteHeadInputTouchID)
            Not(TempTouchEnded)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
        And(
            Equal(NoteHeadState Despawned)
            GreaterOr(Subtract(Time InputOffset) NoteHeadTime)
            Not(TempTouchOccupied)
            IsTouchY
            GreaterOr(TempTouchX Subtract(NoteHeadX LaneWidth))
            LessOr(TempTouchX Add(NoteHeadX LaneWidth))
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
    )
)

ProcessTouchDiscontinue:And(
    Or(
        TempTouchEnded
        Greater(TempTouchY JudgeYMax)
        Greater(Subtract(Time InputOffset NoteTailTime) GoodWindow)
    )
    Set(EntityMemory *InputState Terminated)
)

ProcessFlickDiscontinue:And(
    Or(
        TempTouchEnded
        Greater(Subtract(Time InputOffset NoteTailTime) GoodWindow)
    )
    Set(EntityMemory *InputState Terminated)
)

UpdateNoteHeadTimeDistance:Set(EntityMemory *NoteHeadTimeDistance Subtract(Time NoteHeadTime))
UpdateNoteTailTimeDistance:Set(EntityMemory *NoteTailTimeDistance Subtract(Time NoteTailTime))

UpdateNoteTailScale:Set(EntityMemory *NoteTailScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(NoteTailTimeDistance NoteScreenTime)))))

DrawNoteTail:Execute(
    Set(EntityMemory *NoteTailScale1 Multiply(NoteBaseY1 NoteTailScale))
    Set(EntityMemory *NoteTailScale2 Multiply(NoteBaseY2 NoteTailScale))
    Set(EntityMemory *NoteTailY1 Add(1 Multiply(-1.63265 NoteTailScale1)))
    Set(EntityMemory *NoteTailY2 Add(1 Multiply(-1.63265 NoteTailScale2)))
    Draw(
        NoteTexture
        Multiply(NoteTailScale1 NoteTailX1) NoteTailY1
        Multiply(NoteTailScale2 NoteTailX1) NoteTailY2
        Multiply(NoteTailScale2 NoteTailX2) NoteTailY2
        Multiply(NoteTailScale1 NoteTailX2) NoteTailY1
        LayerNoteBody
        1
    )
)

DrawNoteTailArrow:Execute(
    Set(EntityMemory *NoteTailY Add(1 Multiply(-1.63265 NoteTailScale)))
    Draw(
        TextureArrow
        Multiply(NoteTailScale NoteTailX1) NoteTailY
        Multiply(NoteTailScale NoteTailX1) Add(NoteTailY Multiply(NoteTailScale NoteWidth))
        Multiply(NoteTailScale NoteTailX2) Add(NoteTailY Multiply(NoteTailScale NoteWidth))
        Multiply(NoteTailScale NoteTailX2) NoteTailY
        LayerNoteMarker
        1
    )
)

DrawNoteSlide:And(
    Greater(NoteTailTime Time)
    Execute(
        If(
            Or(
                InputState
                And(
                    Auto
                    GreaterOr(Time NoteHeadTime)
                )
            )
            Execute(
                Set(EntityMemory *NoteHeadScale 1)
                Set(EntityMemory *NoteHeadY -0.63265)

                Set(EntityMemory *NoteHeadX Multiply(LaneWidth RemapClamped(NoteHeadTime NoteTailTime NoteHeadLane NoteTailLane Time)))

                Set(EntityMemory *NoteHeadX1 Subtract(NoteHeadX HalfNoteWidth))
                Set(EntityMemory *NoteHeadX2 Add(NoteHeadX HalfNoteWidth))

                Draw(
                    TextureSlide
                    Multiply(NoteBaseY1 NoteHeadX1) Subtract(-0.63265 NoteHeight)
                    Multiply(NoteBaseY2 NoteHeadX1) Add(-0.63265 NoteHeight)
                    Multiply(NoteBaseY2 NoteHeadX2) Add(-0.63265 NoteHeight)
                    Multiply(NoteBaseY1 NoteHeadX2) Subtract(-0.63265 NoteHeight)
                    LayerNoteSlide
                    1
                )
            )
            Execute(
                Set(EntityMemory *NoteHeadScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(NoteHeadTimeDistance NoteScreenTime)))))
                Set(EntityMemory *NoteHeadY Add(1 Multiply(-1.63265 NoteHeadScale)))
            )
        )

        Set(EntityMemory *NoteTailY Add(1 Multiply(-1.63265 NoteTailScale)))

        Draw(
            TextureLong
            Multiply(NoteHeadScale NoteHeadX1) NoteHeadY
            Multiply(NoteTailScale NoteTailX1) NoteTailY
            Multiply(NoteTailScale NoteTailX2) NoteTailY
            Multiply(NoteHeadScale NoteHeadX2) NoteHeadY
            LayerNoteConnector
            ConnectorAlpha
        )
    )
)

PlayTapEffect:And(
    NoteEffect
    Spawn(
        7
        Time
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)
PlayAutoTapEffect:And(
    NoteEffect
    Spawn(
        7
        NoteTailTime
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)

PlayFlickEffect:And(
    NoteEffect
    Spawn(
        8
        Time
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)
PlayAutoFlickEffect:And(
    NoteEffect
    Spawn(
        8
        NoteTailTime
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)

PlayJudgmentSound:And(
    SoundEffect
    Play(Judgment MinEffectTime)
)

PlayFlickSound:And(
    SoundEffect
    Play(EffectFlick MinEffectTime)
)

PlayEmptySound:And(
    SoundEffect
    Play(EffectEmpty MinEffectTime)
)



// Effect Class

UpdateEffectTimeDistance:Set(EntityMemory *EffectTimeDistance Subtract(Time EffectTime))

DrawEffectC:Execute(
    Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInCubic(Divide(EffectTimeDistance 0.6))) 2))

    Set(EntityMemory *HalfEffectWidth Multiply(HalfNoteWidth 2 EaseOutCubic(Divide(EffectTimeDistance 0.6))))
    Set(EntityMemory *HalfEffectHeight Multiply(0.7 HalfEffectWidth))
    UpdateEffectPosition

    DrawEffectCB
    DrawEffectCF
)

UpdateEffectPosition:Execute(
    Set(EntityMemory *EffectCX1 Subtract(EffectX HalfEffectWidth))
    Set(EntityMemory *EffectCX2 Add(EffectX HalfEffectWidth))
    Set(EntityMemory *EffectCY1 Subtract(-0.63265 HalfEffectHeight))
    Set(EntityMemory *EffectCY2 Add(-0.63265 HalfEffectHeight))
)

DrawEffectCB:Draw(
    EffectCB
    EffectCX1 EffectCY1
    EffectCX1 EffectCY2
    EffectCX2 EffectCY2
    EffectCX2 EffectCY1
    LayerEffectCB
    EffectAlpha
)

DrawEffectCF:Draw(
    EffectCF
    EffectCX1 EffectCY1
    EffectCX1 EffectCY2
    EffectCX2 EffectCY2
    EffectCX2 EffectCY1
    LayerEffectCF
    EffectAlpha
)

DrawEffectL:Execute(
    DrawEffectLF
    DrawEffectLB
)

DrawEffectLF:Execute(
    Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInOutCubic(Divide(EffectTimeDistance 0.6))) 2))
    Set(EntityMemory *EffectLY2 Add(-0.63265 Multiply(HalfNoteWidth 4 EaseOutCubic(Divide(EffectTimeDistance 0.6)))))

    Draw(
        EffectLF
        EffectLX1 -0.63265
        EffectLX2 EffectLY2
        EffectLX3 EffectLY2
        EffectLX4 -0.63265
        LayerEffectLF
        EffectAlpha
    )
)

DrawEffectLB:Draw(
    EffectLB
    EffectLX1 -0.63265
    EffectLX2 EffectLY1
    EffectLX3 EffectLY1
    EffectLX4 -0.63265
    LayerEffectLB
    EffectAlpha
)



// #0: Initialization

#0.updateSequential:Execute(
    Set(LevelMemory *StageAspectRatio If(StageAspectRatioLock 1.77778 AspectRatio))
    Set(LevelMemory *LaneWidth Divide(StageAspectRatio 4.375))
    Set(LevelMemory *NoteWidth Multiply(LaneWidth NoteSize))
    Set(LevelMemory *NoteHeight Multiply(NoteSize 0.08571))
    Set(LevelMemory *HalfNoteWidth Divide(NoteWidth 2))
    Set(LevelMemory *NoteBaseY1 Subtract(1 Divide(NoteHeight -1.63265)))
    Set(LevelMemory *NoteBaseY2 Add(1 Divide(NoteHeight -1.63265)))
    Set(LevelMemory *NoteScreenTime Divide(Subtract(12 NoteSpeed) 2))
    true
)



// #1: Stage

#1.shouldSpawn:Equal(Get(EntityInfoArray *State) Despawned)

#1.initialize:Execute(
    Set(EntityMemory *JudgeX1 Multiply(-1 AspectRatio))
    Set(EntityMemory *JudgeX2 Multiply(1 AspectRatio))
    Set(EntityMemory *StageBorderBL Multiply(-3.75 LaneWidth))
    Set(EntityMemory *StageBorderBR Multiply(3.75 LaneWidth))
    Set(EntityMemory *StageBorderTL Multiply(0.05 StageBorderBL))
    Set(EntityMemory *StageBorderTR Multiply(0.05 StageBorderBR))

    Set(EntityMemory *Looper 0)
    While(
        Less(Looper 8)
        SetShifted(EntityMemory *LaneBX Looper Multiply(LaneWidth Subtract(Looper 3.5)))
        SetShifted(EntityMemory *LaneTX Looper Multiply(0.05 GetShifted(EntityMemory *LaneBX Looper)))
        Set(EntityMemory *Looper Add(Looper 1))
    )
)

#1.updateSequential:And(
    StageTilt
    Execute(
        Set(LevelTransform 4 Multiply(0.5 Add(Get(LevelTransform 4) Divide(Tilt AspectRatio -10))))
        Set(EntityMemory *Tilt 0)
    )
)

#1.updateParallel:Execute(
    Draw(
        TextureJudgeLine
        JudgeX1 -0.65265
        JudgeX1 -0.61265
        JudgeX2 -0.61265
        JudgeX2 -0.65265
        LayerJudgeLine
        1
    )
    Draw(
        TextureStageL
        StageBorderBL -0.63265
        StageBorderTL 0.91837
        GetShifted(EntityMemory *LaneTX 0) 0.91837
        GetShifted(EntityMemory *LaneBX 0) -0.63265
        LayerStage
        1
    )
    Draw(
        TextureStageR
        GetShifted(EntityMemory *LaneBX 7) -0.63265
        GetShifted(EntityMemory *LaneTX 7) 0.91837
        StageBorderTR 0.91837
        StageBorderBR -0.63265
        LayerStage
        1
    )

    Set(EntityMemory *Looper 0)
    While(
        Less(Looper 7)
        Draw(
            TextureLane
            GetShifted(EntityMemory *LaneBX Looper) -0.63265
            GetShifted(EntityMemory *LaneTX Looper) 0.91837
            GetShifted(EntityMemory *LaneTX Add(Looper 1)) 0.91837
            GetShifted(EntityMemory *LaneBX Add(Looper 1)) -0.63265
            LayerStage
            1
        )
        Set(EntityMemory *Looper Add(Looper 1))
    )
)

#1.touch@1:Or(
    Auto
    Execute(
        Set(EntityMemory *Tilt Add(Tilt TempTouchX))
        And(
            TempTouchStarted
            IsTouchY
            Execute(
                Set(EntityMemory *Looper 0)
                While(
                    Less(Looper 7)
                    And(
                        GreaterOr(TempTouchX GetShifted(EntityMemory *LaneBX Looper))
                        LessOr(TempTouchX GetShifted(EntityMemory *LaneBX Add(Looper 1)))
                        Execute(
                            And(
                                Not(TempTouchOccupied)
                                Execute(
                                    PlayEmptySound
                                    And(
                                        NoteEffect
                                        Spawn(
                                            9
                                            Time
                                            Subtract(Looper 3)
                                        )
                                    )
                                )
                            )
                            And(
                                LaneEffect
                                Spawn(
                                    11
                                    Time
                                    GetShifted(EntityMemory *LaneBX Looper)
                                    GetShifted(EntityMemory *LaneTX Looper)
                                    GetShifted(EntityMemory *LaneTX Add(Looper 1))
                                    GetShifted(EntityMemory *LaneBX Add(Looper 1))
                                )
                            )
                        )
                    )
                    Set(EntityMemory *Looper Add(Looper 1))
                )
            )
        )
    )
)



// #2: Tap Note

#2.shouldSpawn:IsNoteTailOnScreen

#2.initialize:Execute(
    InitNoteTail
    InitSimLine
    InitAutoNormal
)

#2.touch:Or(
    Auto
    And(
        Not(InputState)
        IsNoteTailInGoodWindow
        TempTouchStarted
        Not(TempTouchOccupied)
        IsTouchY
        IsTouchXInTailLane
        Execute(
            Set(TemporaryMemory *TempTouchOccupied true)
            Set(EntityMemory *InputState Terminated)
            Set(EntitySharedMemory *InputSuccess true)
            Set(EntitySharedMemory *InputTouchID TempTouchID)
            Set(EntityInput *Judgment JudgeSimple(Subtract(TempTouchST InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
            PlayTapEffect
            PlayJudgmentSound
        )
    )
)

#2.updateParallel:Execute(
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteTail
        )
    )
)



// #3: Flick Note

#3.shouldSpawn:IsNoteTailOnScreen

#3.initialize:Execute(
    InitNoteTail
    InitSimLine
    InitAutoFlick
)

#3.touch:Or(
    Auto
    Execute(
        And(
            Not(InputState)
            IsNoteTailInGoodWindow
            TempTouchStarted
            Not(TempTouchOccupied)
            IsTouchY
            IsTouchXInTailLane
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntityMemory *ActivationTime TempTouchST)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Or(
                    And(
                        IsNoteTailInGoodWindow
                        GreaterOr(TempTouchVR MinVR)
                        Execute(
                            Set(EntityMemory *InputState Terminated)
                            Set(EntitySharedMemory *InputSuccess true)
                            Set(EntityInput *Judgment JudgeSimple(Subtract(ActivationTime InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                            PlayFlickEffect
                            PlayFlickSound
                            true
                        )
                    )
                    ProcessFlickDiscontinue
                )
            )
        )
    )
)

#3.updateParallel:Execute(
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoFlickEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteTail
            DrawNoteTailArrow
        )
    )
)



// #4: Slide Touch Note

#4.shouldSpawn:IsNoteHeadOnScreen

#4.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitAutoNormal
)

#4.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Or(
                    And(
                        GreaterOr(Subtract(Time InputOffset) NoteTailTime)
                        IsTouchY
                        IsTouchXInTailLane
                        Execute(
                            Set(EntityMemory *InputState Terminated)
                            Set(EntitySharedMemory *InputSuccess true)
                            Set(EntityInput *Judgment JudgeSimple(Subtract(Time InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                            PlayTapEffect
                            PlayJudgmentSound
                            true
                        )
                    )
                    ProcessTouchDiscontinue
                )
            )
        )
    )
)

#4.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        And(
            Not(Auto)
            Not(InputState)
            Greater(Subtract(NoteHeadTimeDistance InputOffset) GoodWindow)
        )
        Equal(InputState Terminated)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                DrawNoteTail
            )
        )
    )
)



// #5: Slide Release Note

#5.shouldSpawn:IsNoteHeadOnScreen

#5.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitSimLine
    InitAutoNormal
)

#5.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Or(
                    And(
                        IsNoteTailInGoodWindow
                        TempTouchEnded
                        IsTouchY
                        IsTouchXInTailLane
                        Execute(
                            Set(EntityMemory *InputState Terminated)
                            Set(EntitySharedMemory *InputSuccess true)
                            Set(EntityInput *Judgment JudgeSimple(Subtract(TempTouchT InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                            PlayTapEffect
                            PlayJudgmentSound
                            true
                        )
                    )
                    ProcessTouchDiscontinue
                )
            )
        )
    )
)

#5.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        And(
            Not(Auto)
            Not(InputState)
            Greater(Subtract(NoteHeadTimeDistance InputOffset) GoodWindow)
        )
        Equal(InputState Terminated)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                DrawNoteTail
            )
        )
    )
)



// #6: Slide Flick Note

#6.shouldSpawn:IsNoteHeadOnScreen

#6.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitSimLine
    InitAutoFlick
)

#6.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Or(
                    And(
                        Equal(InputState Activated)
                        GreaterOr(Subtract(Time InputOffset) NoteTailTime)
                        IsTouchY
                        IsTouchXInTailLane
                        Execute(
                            Set(EntityMemory *InputState ActivatedNext)
                            true
                        )
                    )
                    And(
                        Equal(InputState ActivatedNext)
                        GreaterOr(TempTouchVR MinVR)
                        Execute(
                            Set(EntityMemory *InputState Terminated)
                            Set(EntitySharedMemory *InputSuccess true)
                            Set(EntityInput *Judgment JudgeSimple(Subtract(Time InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                            PlayFlickEffect
                            PlayFlickSound
                            true
                        )
                    )
                    ProcessFlickDiscontinue
                )
            )
        )
    )
)

#6.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        And(
            Not(Auto)
            Not(InputState)
            Greater(Subtract(NoteHeadTimeDistance InputOffset) GoodWindow)
        )
        Equal(InputState Terminated)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                Execute(
                    DrawNoteTail
                    DrawNoteTailArrow
                )
            )
        )
    )
)



// #7: Tap Effect

#7.initialize:Execute(
    Set(EntityMemory *EffectLX1 Subtract(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLX2 Subtract(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX3 Add(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX4 Add(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLY1 Add(-0.63265 Multiply(3 HalfNoteWidth)))
)

#7.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            DrawEffectC
            DrawEffectL
        )
    )
)



// #8: Flick Effect

#8.initialize:Execute(
    Set(EntityMemory *EffectLX1 Subtract(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLX2 Subtract(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX3 Add(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX4 Add(EffectX Multiply(0.5 HalfNoteWidth)))
)

#8.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            DrawEffectC
            DrawEffectLF

            And(
                Less(EffectTimeDistance 0.2)
                Execute(
                    Set(EntityMemory *EffectAlpha 0.5)
                    Set(
                        EntityMemory *HalfEffectWidth
                        Multiply(HalfNoteWidth 1.5 Subtract(0.2 EffectTimeDistance) 5)
                    )
                    Set(
                        EntityMemory *HalfEffectHeight
                        Multiply(HalfNoteWidth 2 Add(0.4 EffectTimeDistance) 5)
                    )
                    UpdateEffectPosition
                    DrawEffectCB
                )
            )
        )
    )
)



// #9: Empty Tap Effect

#9.initialize:Execute(
    Set(EntityMemory *EffectLX1 Multiply(Subtract(EffectX 0.5) LaneWidth))
    Set(EntityMemory *EffectLX3 Multiply(Add(EffectX 0.5) LaneWidth))
    Set(EntityMemory *EffectLY1 Add(-0.63265 Multiply(0.5 LaneWidth)))
)

#9.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInOutCubic(Divide(EffectTimeDistance 0.6))) 2))
            Set(EntityMemory *EffectLY2 Add(-0.63265 Multiply(LaneWidth EaseOutCubic(Divide(EffectTimeDistance 0.6)))))

            Draw(
                TextureEffectLF
                EffectLX1 -0.63265
                EffectLX1 EffectLY2
                EffectLX3 EffectLY2
                EffectLX3 -0.63265
                LayerEffectLF
                EffectAlpha
            )

            Draw(
                TextureEffectLB
                EffectLX1 -0.63265
                EffectLX1 EffectLY1
                EffectLX3 EffectLY1
                EffectLX3 -0.63265
                LayerEffectLB
                EffectAlpha
            )
        )
    )
)



// #10: Sim Line

#10.initialize:Execute(
    Set(EntityMemory *SimLineTime SimLineTime1)
    Set(EntityMemory *SimLineX1 Multiply(SimLineLane1 LaneWidth))
    Set(EntityMemory *SimLineX2 Multiply(SimLineLane2 LaneWidth))
)

#10.updateParallel:Or(
    And(
        Auto
        GreaterOr(Time SimLineTime)
    )
    Equal(SimLineState1 Despawned)
    Equal(SimLineState2 Despawned)
    And(
        LessOr(Subtract(SimLineTime Time) NoteScreenTime)
        Execute(
            Set(EntityMemory *SimLineTimeDistance Subtract(Time SimLineTime))
            Set(EntityMemory *SimLineScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(SimLineTimeDistance NoteScreenTime)))))
            Set(EntityMemory *SimLineScale1 Multiply(NoteBaseY1 SimLineScale))
            Set(EntityMemory *SimLineScale2 Multiply(NoteBaseY2 SimLineScale))
            Set(EntityMemory *SimLineY1 Add(1 Multiply(-1.63265 SimLineScale1)))
            Set(EntityMemory *SimLineY2 Add(1 Multiply(-1.63265 SimLineScale2)))
            Draw(
                TextureSimLine
                Multiply(SimLineScale1 SimLineX1) SimLineY1
                Multiply(SimLineScale2 SimLineX1) SimLineY2
                Multiply(SimLineScale2 SimLineX2) SimLineY2
                Multiply(SimLineScale1 SimLineX2) SimLineY1
                LayerSimLine
                1
            )
        )
    )
)



// #11: Lane Effect

#11.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.2)
        Draw(
            TextureEffectLB
            LaneEffectX1 -0.63265
            LaneEffectX2 0.91837
            LaneEffectX3 0.91837
            LaneEffectX4 -0.63265
            LayerLaneEffect
            Subtract(1 Divide(EffectTimeDistance 0.2))
        )
    )
)



// Constants

true:1
false:0

Waiting:0
Spawned:1
Despawned:2

Waiting:0
Activated:1
ActivatedNext:2
Terminated:3

PhaseBegan:1
PhaseStationary:2
PhaseMoved:3
PhaseEnded:4

PerfectWindow:0.05
GreatWindow:0.1
GoodWindow:0.15

JudgeYMax:0
MinVR:1.5

MinEffectTime:0.02

LayerNoteMarker:101
LayerNoteBody:100
LayerNoteSlide:99
LayerNoteConnector:98
LayerSimLine:97
LayerEffectLF:53
LayerEffectCF:52
LayerEffectLB:51
LayerEffectCB:50
LayerJudgeLine:2
LayerLaneEffect:1
LayerStage:0

JudgmentMiss:0
JudgmentPerfect:1
JudgmentGreat:2
JudgmentGood:3



// Texture identifiers

TextureJudgeLine:41000
TextureLane:40100
TextureSimLine:12006
TextureSlide:1002
TextureLong:11002
TextureArrow:21001
TextureEffectLB:33000
TextureEffectLF:34000
TextureStageL:40001
TextureStageR:40002



// Effect identifiers

EffectMiss:0
EffectPerfect:1
EffectGreat:2
EffectGood:3
EffectFlick:4
EffectEmpty:5



// Block identifiers

LevelMemory:0
LevelData:1
LevelOption:2
LevelTransform:3
LevelBackground:4

EntityInfoArray:10
EntityDataArray:11
EntitySharedMemoryArray:12

EntityInfo:20
EntityMemory:21
EntityData:22
EntityInput:23
EntitySharedMemory:24

TemporaryMemory:100
TemporaryData:101



// Level Memory Layout

*StageAspectRatio:0
*LaneWidth:1
*NoteWidth:2
*NoteHeight:3
*HalfNoteWidth:4
*NoteBaseY1:5
*NoteBaseY2:6
*NoteScreenTime:7

StageAspectRatio:Get(LevelMemory *StageAspectRatio)
LaneWidth:Get(LevelMemory *LaneWidth)
NoteWidth:Get(LevelMemory *NoteWidth)
NoteHeight:Get(LevelMemory *NoteHeight)
HalfNoteWidth:Get(LevelMemory *HalfNoteWidth)
NoteBaseY1:Get(LevelMemory *NoteBaseY1)
NoteBaseY2:Get(LevelMemory *NoteBaseY2)
NoteScreenTime:Get(LevelMemory *NoteScreenTime)



// Level Data Layout

*Time:0
*DeltaTime:1
*AspectRatio:2
*AudioOffset:3
*InputOffset:4

Time:Get(LevelData *Time)
DeltaTime:Get(LevelData *DeltaTime)
AspectRatio:Get(LevelData *AspectRatio)
AudioOffset:Get(LevelData *AudioOffset)
InputOffset:Get(LevelData *InputOffset)



// Level Option Layout

*Auto:0
*Offset:1
*Speed:2
*NoteSpeed:3
*NoteSize:4
*ConnectorAlpha:5
*Mirror:6
*SimLine:7
*SoundEffect:8
*NoteEffect:9
*LaneEffect:10
*StageTilt:11
*StageAspectRatioLock:12

Auto:Get(LevelOption *Auto)
Offset:Get(LevelOption *Offset)
Speed:Get(LevelOption *Speed)
NoteSpeed:Get(LevelOption *NoteSpeed)
NoteSize:Get(LevelOption *NoteSize)
ConnectorAlpha:Get(LevelOption *ConnectorAlpha)
Mirror:Get(LevelOption *Mirror)
SimLine:Get(LevelOption *SimLine)
SoundEffect:Get(LevelOption *SoundEffect)
NoteEffect:Get(LevelOption *NoteEffect)
LaneEffect:Get(LevelOption *LaneEffect)
StageTilt:Get(LevelOption *StageTilt)
StageAspectRatioLock:Get(LevelOption *StageAspectRatioLock)



// Entity Info Layout

*Index:0
*Archetype:1
*State:2

Index:Get(EntityInfo *Index)
Archetype:Get(EntityInfo *Archetype)
State:Get(EntityInfo *State)

NoteHeadState:GetShifted(EntityInfoArray NoteHeadInfoOffset *State)

SimLineState1:GetShifted(EntityInfoArray SimLineInfoOffset1 *State)
SimLineState2:GetShifted(EntityInfoArray SimLineInfoOffset2 *State)



// Entity Input Layout

*Judgment:0

Judgment:Get(EntityInput *Judgment)



// Touch Temporary Memory Layout

*TempTouchOccupied:0

TempTouchOccupied:Get(TemporaryMemory *TempTouchOccupied)


// Touch Temporary Data Layout

*TempTouchID:0
*TempTouchStarted:1
*TempTouchEnded:2
*TempTouchT:3
*TempTouchST:4
*TempTouchX:5
*TempTouchY:6
*TempTouchSX:7
*TempTouchSY:8
*TempTouchDX:9
*TempTouchDY:10
*TempTouchVX:11
*TempTouchVY:12
*TempTouchVR:13
*TempTouchVW:14

TempTouchID:Get(TemporaryData *TempTouchID)
TempTouchStarted:Get(TemporaryData *TempTouchStarted)
TempTouchEnded:Get(TemporaryData *TempTouchEnded)
TempTouchT:Get(TemporaryData *TempTouchT)
TempTouchST:Get(TemporaryData *TempTouchST)
TempTouchX:Get(TemporaryData *TempTouchX)
TempTouchY:Get(TemporaryData *TempTouchY)
TempTouchSX:Get(TemporaryData *TempTouchSX)
TempTouchSY:Get(TemporaryData *TempTouchSY)
TempTouchDX:Get(TemporaryData *TempTouchDX)
TempTouchDY:Get(TemporaryData *TempTouchDY)
TempTouchVX:Get(TemporaryData *TempTouchVX)
TempTouchVY:Get(TemporaryData *TempTouchVY)
TempTouchVR:Get(TemporaryData *TempTouchVR)
TempTouchVW:Get(TemporaryData *TempTouchVW)



// #1 Memory Layout

*JudgeX1:0
*JudgeX2:1
*Tilt:2
*StageBorderBL:3
*StageBorderBR:4
*StageBorderTL:5
*StageBorderTR:6
*LaneBX:7
*LaneTX:15
*Looper:63

JudgeX1:Get(EntityMemory *JudgeX1)
JudgeX2:Get(EntityMemory *JudgeX2)
Tilt:Get(EntityMemory *Tilt)
StageBorderBL:Get(EntityMemory *StageBorderBL)
StageBorderTL:Get(EntityMemory *StageBorderTL)
StageBorderBR:Get(EntityMemory *StageBorderBR)
StageBorderTR:Get(EntityMemory *StageBorderTR)
Looper:Get(EntityMemory *Looper)



// Note Class Memory Layout

*InputState:32
*ActivationTime:33
*NoteHeadTimeDistance:34
*NoteHeadScale:35
*NoteHeadX:36
*NoteHeadX1:37
*NoteHeadX2:38
*NoteHeadY:39
*NoteTailTimeDistance:40
*NoteTailScale:41
*NoteTailScale1:42
*NoteTailScale2:43
*NoteTailX:44
*NoteTailX1:45
*NoteTailX2:46
*NoteTailY:47
*NoteTailY1:48
*NoteTailY2:49

InputState:Get(EntityMemory *InputState)
ActivationTime:Get(EntityMemory *ActivationTime)
NoteHeadTimeDistance:Get(EntityMemory *NoteHeadTimeDistance)
NoteHeadScale:Get(EntityMemory *NoteHeadScale)
NoteHeadX:Get(EntityMemory *NoteHeadX)
NoteHeadX1:Get(EntityMemory *NoteHeadX1)
NoteHeadX2:Get(EntityMemory *NoteHeadX2)
NoteHeadY:Get(EntityMemory *NoteHeadY)
NoteTailTimeDistance:Get(EntityMemory *NoteTailTimeDistance)
NoteTailScale:Get(EntityMemory *NoteTailScale)
NoteTailScale1:Get(EntityMemory *NoteTailScale1)
NoteTailScale2:Get(EntityMemory *NoteTailScale2)
NoteTailX:Get(EntityMemory *NoteTailX)
NoteTailX1:Get(EntityMemory *NoteTailX1)
NoteTailX2:Get(EntityMemory *NoteTailX2)
NoteTailY:Get(EntityMemory *NoteTailY)
NoteTailY1:Get(EntityMemory *NoteTailY1)
NoteTailY2:Get(EntityMemory *NoteTailY2)



// Note Class Shared Memory Layout

*InputSuccess:0
*InputTouchID:1

InputSuccess:Get(EntitySharedMemory *InputSuccess)
InputTouchID:Get(EntitySharedMemory *InputTouchID)

NoteHeadInputSuccess:GetShifted(EntitySharedMemoryArray NoteHeadSharedMemoryOffset *InputSuccess)
NoteHeadInputTouchID:GetShifted(EntitySharedMemoryArray NoteHeadSharedMemoryOffset *InputTouchID)



// Note Class Data Layout

*NoteHeadIndex:0
*NoteTailTime:1
*NoteTailLane:2
*NoteSimLineIndex:3
*NoteTexture:4
*NoteEffectCB:5
*NoteEffectCF:6
*NoteEffectLB:7
*NoteEffectLF:8

NoteHeadIndex:Get(EntityData *NoteHeadIndex)
NoteTailTime:Divide(Get(EntityData *NoteTailTime) Speed)
NoteTailLane:Multiply(Get(EntityData *NoteTailLane) If(Mirror -1 1))
NoteSimLineIndex:Get(EntityData *NoteSimLineIndex)
NoteTexture:Get(EntityData *NoteTexture)
NoteEffectCB:Get(EntityData *NoteEffectCB)
NoteEffectCF:Get(EntityData *NoteEffectCF)
NoteEffectLB:Get(EntityData *NoteEffectLB)
NoteEffectLF:Get(EntityData *NoteEffectLF)

NoteHeadInfoOffset:Multiply(NoteHeadIndex 3)
NoteHeadDataOffset:Multiply(NoteHeadIndex 32)
NoteHeadSharedMemoryOffset:Multiply(NoteHeadIndex 32)

NoteHeadTime:Divide(GetShifted(EntityDataArray NoteHeadDataOffset *NoteTailTime) Speed)
NoteHeadLane:Multiply(GetShifted(EntityDataArray NoteHeadDataOffset *NoteTailLane) If(Mirror -1 1))

SimLineTime1:Divide(GetShifted(EntityDataArray SimLineDataOffset1 *NoteTailTime) Speed)
SimLineTime2:Divide(GetShifted(EntityDataArray SimLineDataOffset2 *NoteTailTime) Speed)
SimLineLane1:Multiply(GetShifted(EntityDataArray SimLineDataOffset1 *NoteTailLane) If(Mirror -1 1))
SimLineLane2:Multiply(GetShifted(EntityDataArray SimLineDataOffset2 *NoteTailLane) If(Mirror -1 1))



// Effect Class Memory Layout

*EffectTimeDistance:32
*EffectLX1:33
*EffectLX2:34
*EffectLX3:35
*EffectLX4:36
*EffectLY1:37
*EffectLY2:38
*HalfEffectWidth:39
*HalfEffectHeight:40
*EffectAlpha:41
*EffectCX1:42
*EffectCX2:43
*EffectCY1:44
*EffectCY2:45

EffectTimeDistance:Get(EntityMemory *EffectTimeDistance)
EffectLX1:Get(EntityMemory *EffectLX1)
EffectLX2:Get(EntityMemory *EffectLX2)
EffectLX3:Get(EntityMemory *EffectLX3)
EffectLX4:Get(EntityMemory *EffectLX4)
EffectLY1:Get(EntityMemory *EffectLY1)
EffectLY2:Get(EntityMemory *EffectLY2)
HalfEffectWidth:Get(EntityMemory *HalfEffectWidth)
HalfEffectHeight:Get(EntityMemory *HalfEffectHeight)
EffectAlpha:Get(EntityMemory *EffectAlpha)
EffectCX1:Get(EntityMemory *EffectCX1)
EffectCX2:Get(EntityMemory *EffectCX2)
EffectCY1:Get(EntityMemory *EffectCY1)
EffectCY2:Get(EntityMemory *EffectCY2)



// #7, #8, #11 Memory Layout

*EffectTime:0
*EffectX:1
*EffectCB:2
*EffectCF:3
*EffectLB:4
*EffectLF:5

EffectTime:Get(EntityMemory *EffectTime)
EffectX:Get(EntityMemory *EffectX)
EffectCB:Get(EntityMemory *EffectCB)
EffectCF:Get(EntityMemory *EffectCF)
EffectLB:Get(EntityMemory *EffectLB)
EffectLF:Get(EntityMemory *EffectLF)



// #10 Memory Layout

*SimLineIndex1:0
*SimLineIndex2:1
*SimLineTime:2
*SimLineX1:3
*SimLineX2:4
*SimLineTimeDistance:5
*SimLineScale:6
*SimLineScale1:7
*SimLineScale2:8
*SimLineY1:9
*SimLineY2:10

SimLineIndex1:Get(EntityMemory *SimLineIndex1)
SimLineIndex2:Get(EntityMemory *SimLineIndex2)
SimLineTime:Get(EntityMemory *SimLineTime)
SimLineX1:Get(EntityMemory *SimLineX1)
SimLineX2:Get(EntityMemory *SimLineX2)
SimLineTimeDistance:Get(EntityMemory *SimLineTimeDistance)
SimLineScale:Get(EntityMemory *SimLineScale)
SimLineScale1:Get(EntityMemory *SimLineScale1)
SimLineScale2:Get(EntityMemory *SimLineScale2)
SimLineY1:Get(EntityMemory *SimLineY1)
SimLineY2:Get(EntityMemory *SimLineY2)

SimLineInfoOffset1:Multiply(SimLineIndex1 3)
SimLineInfoOffset2:Multiply(SimLineIndex2 3)
SimLineDataOffset1:Multiply(SimLineIndex1 32)
SimLineDataOffset2:Multiply(SimLineIndex2 32)



// #11 Memory Layout

*LaneEffectX1:1
*LaneEffectX2:2
*LaneEffectX3:3
*LaneEffectX4:4

LaneEffectX1:Get(EntityMemory *LaneEffectX1)
LaneEffectX2:Get(EntityMemory *LaneEffectX2)
LaneEffectX3:Get(EntityMemory *LaneEffectX3)
LaneEffectX4:Get(EntityMemory *LaneEffectX4)
