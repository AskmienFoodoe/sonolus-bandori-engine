//
// Bandori Engine
// For Sonolus 0.3.5
//
// A recreation of BanG Dream! Girls Band Party engine
// By Burrito
//



// Note Class

IsNoteHeadOnScreen:LessOr(Subtract(NoteHeadTime Time) NoteScreenTime)
IsNoteTailOnScreen:LessOr(Subtract(NoteTailTime Time) NoteScreenTime)

InitNoteHead:Execute(
    Set(EntityMemory *NoteHeadX Multiply(LaneWidth NoteHeadLane))
    Set(EntityMemory *NoteHeadX1 Subtract(NoteHeadX HalfNoteWidth))
    Set(EntityMemory *NoteHeadX2 Add(NoteHeadX HalfNoteWidth))
)
InitNoteTail:Execute(
    Set(EntityMemory *NoteTailX Multiply(LaneWidth NoteTailLane))
    Set(EntityMemory *NoteTailX1 Subtract(NoteTailX HalfNoteWidth))
    Set(EntityMemory *NoteTailX2 Add(NoteTailX HalfNoteWidth))
)
InitSimLine:And(
    SimLine
    NoteSimLineIndex
    Spawn(10 Index NoteSimLineIndex)
)

InitAutoNormal:And(
    Auto
    Execute(
        PlayScheduled(EffectPerfect NoteTailTime MinEffectTime)
        Set(EntityInput *Judgment JudgmentPerfect)
        Set(EntityInput *Bucket NoteBucket)
    )
)
InitAutoFlick:And(
    Auto
    Execute(
        PlayScheduled(EffectFlick NoteTailTime MinEffectTime)
        Set(EntityInput *Judgment JudgmentPerfect)
        Set(EntityInput *Bucket NoteBucket)
    )
)

IsNoteTailInGoodWindow:LessOr(Subtract(NoteTailTime Subtract(Time InputOffset)) GoodWindow)

IsTouchY:LessOr(TempTouchY JudgeYMax)
IsTouchXInTailLane:And(
    GreaterOr(TempTouchX Subtract(NoteTailX LaneWidth))
    LessOr(TempTouchX Add(NoteTailX LaneWidth))
)

ProcessTouchHead:And(
    Not(InputState)
    If(
        NoteHeadInputSuccess
        And(
            Equal(TempTouchID NoteHeadInputTouchID)
            Not(TempTouchEnded)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
        And(
            Equal(NoteHeadState Despawned)
            GreaterOr(Subtract(Time InputOffset) NoteHeadTime)
            Not(TempTouchOccupied)
            IsTouchY
            GreaterOr(TempTouchX Subtract(NoteHeadX LaneWidth))
            LessOr(TempTouchX Add(NoteHeadX LaneWidth))
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
    )
)

ProcessTouchDiscontinue:And(
    Or(
        TempTouchEnded
        Greater(TempTouchY JudgeYMax)
    )
    Set(EntityMemory *InputState Terminated)
)

ProcessFlickDiscontinue:And(
    TempTouchEnded
    Set(EntityMemory *InputState Terminated)
)

UpdateNoteHeadTimeDistance:Set(EntityMemory *NoteHeadTimeDistance Subtract(Time NoteHeadTime))
UpdateNoteTailTimeDistance:Set(EntityMemory *NoteTailTimeDistance Subtract(Time NoteTailTime))

UpdateNoteTailScale:Set(EntityMemory *NoteTailScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(NoteTailTimeDistance NoteScreenTime)))))

DrawNoteTail:Execute(
    Set(EntityMemory *NoteTailScale1 Multiply(NoteBaseY1 NoteTailScale))
    Set(EntityMemory *NoteTailScale2 Multiply(NoteBaseY2 NoteTailScale))
    Set(EntityMemory *NoteTailY1 Add(LaneYOffset Multiply(LaneYMultiplier NoteTailScale1)))
    Set(EntityMemory *NoteTailY2 Add(LaneYOffset Multiply(LaneYMultiplier NoteTailScale2)))
    Draw(
        NoteTexture
        Multiply(NoteTailScale1 NoteTailX1) NoteTailY1
        Multiply(NoteTailScale2 NoteTailX1) NoteTailY2
        Multiply(NoteTailScale2 NoteTailX2) NoteTailY2
        Multiply(NoteTailScale1 NoteTailX2) NoteTailY1
        LayerNoteBody
        1
    )
)

DrawNoteTailArrow:Execute(
    Set(EntityMemory *NoteTailY Add(LaneYOffset Multiply(LaneYMultiplier NoteTailScale)))
    Draw(
        TextureArrow
        Multiply(NoteTailScale NoteTailX1) NoteTailY
        Multiply(NoteTailScale NoteTailX1) Add(NoteTailY Multiply(NoteTailScale NoteWidth))
        Multiply(NoteTailScale NoteTailX2) Add(NoteTailY Multiply(NoteTailScale NoteWidth))
        Multiply(NoteTailScale NoteTailX2) NoteTailY
        LayerNoteMarker
        1
    )
)

DrawNoteSlide:And(
    Greater(NoteTailTime Time)
    Execute(
        If(
            Or(
                InputState
                And(
                    Auto
                    GreaterOr(Time NoteHeadTime)
                )
            )
            Execute(
                Set(EntityMemory *NoteHeadScale 1)
                Set(EntityMemory *NoteHeadY LaneY1)

                Set(EntityMemory *NoteHeadX Multiply(LaneWidth RemapClamped(NoteHeadTime NoteTailTime NoteHeadLane NoteTailLane Time)))

                Set(EntityMemory *NoteHeadX1 Subtract(NoteHeadX HalfNoteWidth))
                Set(EntityMemory *NoteHeadX2 Add(NoteHeadX HalfNoteWidth))

                Draw(
                    TextureSlide
                    Multiply(NoteBaseY1 NoteHeadX1) Subtract(LaneY1 NoteHeight)
                    Multiply(NoteBaseY2 NoteHeadX1) Add(LaneY1 NoteHeight)
                    Multiply(NoteBaseY2 NoteHeadX2) Add(LaneY1 NoteHeight)
                    Multiply(NoteBaseY1 NoteHeadX2) Subtract(LaneY1 NoteHeight)
                    LayerNoteSlide
                    1
                )
            )
            Execute(
                Set(EntityMemory *NoteHeadScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(NoteHeadTimeDistance NoteScreenTime)))))
                Set(EntityMemory *NoteHeadY Add(LaneYOffset Multiply(LaneYMultiplier NoteHeadScale)))
            )
        )

        Set(EntityMemory *NoteTailY Add(LaneYOffset Multiply(LaneYMultiplier NoteTailScale)))

        Draw(
            TextureLong
            Multiply(NoteHeadScale NoteHeadX1) NoteHeadY
            Multiply(NoteTailScale NoteTailX1) NoteTailY
            Multiply(NoteTailScale NoteTailX2) NoteTailY
            Multiply(NoteHeadScale NoteHeadX2) NoteHeadY
            LayerNoteConnector
            ConnectorAlpha
        )
    )
)

PlayTapEffect:And(
    NoteEffect
    Spawn(
        7
        Time
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)
PlayAutoTapEffect:And(
    NoteEffect
    Spawn(
        7
        NoteTailTime
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)

PlayFlickEffect:And(
    NoteEffect
    Spawn(
        8
        Time
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)
PlayAutoFlickEffect:And(
    NoteEffect
    Spawn(
        8
        NoteTailTime
        NoteTailX
        NoteEffectCB
        NoteEffectCF
        NoteEffectLB
        NoteEffectLF
    )
)

PlayJudgmentSound:And(
    SoundEffect
    Play(Judgment MinEffectTime)
)

PlayFlickSound:And(
    SoundEffect
    Play(EffectFlick MinEffectTime)
)

PlayEmptySound:And(
    SoundEffect
    Play(EffectEmpty MinEffectTime)
)



// Effect Class

UpdateEffectTimeDistance:Set(EntityMemory *EffectTimeDistance Subtract(Time EffectTime))

DrawEffectC:Execute(
    Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInCubic(Divide(EffectTimeDistance 0.6))) 2))

    Set(EntityMemory *HalfEffectWidth Multiply(HalfNoteWidth 2 EaseOutCubic(Divide(EffectTimeDistance 0.6))))
    Set(EntityMemory *HalfEffectHeight Multiply(0.7 HalfEffectWidth))
    UpdateEffectPosition

    DrawEffectCB
    DrawEffectCF
)

UpdateEffectPosition:Execute(
    Set(EntityMemory *EffectCX1 Subtract(EffectX HalfEffectWidth))
    Set(EntityMemory *EffectCX2 Add(EffectX HalfEffectWidth))
    Set(EntityMemory *EffectCY1 Subtract(LaneY1 HalfEffectHeight))
    Set(EntityMemory *EffectCY2 Add(LaneY1 HalfEffectHeight))
)

DrawEffectCB:Draw(
    EffectCB
    EffectCX1 EffectCY1
    EffectCX1 EffectCY2
    EffectCX2 EffectCY2
    EffectCX2 EffectCY1
    LayerEffectCB
    EffectAlpha
)

DrawEffectCF:Draw(
    EffectCF
    EffectCX1 EffectCY1
    EffectCX1 EffectCY2
    EffectCX2 EffectCY2
    EffectCX2 EffectCY1
    LayerEffectCF
    EffectAlpha
)

DrawEffectL:Execute(
    DrawEffectLF
    DrawEffectLB
)

DrawEffectLF:Execute(
    Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInOutCubic(Divide(EffectTimeDistance 0.6))) 2))
    Set(EntityMemory *EffectLY2 Add(LaneY1 Multiply(HalfNoteWidth 4 EaseOutCubic(Divide(EffectTimeDistance 0.6)))))

    Draw(
        EffectLF
        EffectLX1 LaneY1
        EffectLX2 EffectLY2
        EffectLX3 EffectLY2
        EffectLX4 LaneY1
        LayerEffectLF
        EffectAlpha
    )
)

DrawEffectLB:Draw(
    EffectLB
    EffectLX1 LaneY1
    EffectLX2 EffectLY1
    EffectLX3 EffectLY1
    EffectLX4 LaneY1
    LayerEffectLB
    EffectAlpha
)



// #0: Initialization

#0.updateSequential:Execute(
    If(
        StageAspectRatioLock
        If(
            GreaterOr(AspectRatio 1.77778)
            Execute(
                Set(LevelMemory *StageWidth 3.55556)
                Set(LevelMemory *StageHeight 2)
            )
            Execute(
                Set(LevelMemory *StageWidth Multiply(AspectRatio 2))
                Set(LevelMemory *StageHeight Divide(AspectRatio 0.5 1.77778))
            )
        )
        Execute(
            Set(LevelMemory *StageWidth Multiply(AspectRatio 2))
            Set(LevelMemory *StageHeight 2)
        )
    )
    Set(LevelMemory *LaneWidth Divide(StageWidth 2 4.375))
    Set(LevelMemory *LaneYOffset Divide(StageHeight 2))
    Set(LevelMemory *LaneYMultiplier Divide(StageHeight -1.225))
    Set(LevelMemory *LaneY1 Add(LaneYOffset LaneYMultiplier))
    Set(LevelMemory *LaneY2 Add(LaneYOffset Multiply(LaneYMultiplier 0.05)))
    Set(LevelMemory *NoteWidth Multiply(LaneWidth NoteSize))
    Set(LevelMemory *NoteHeight Multiply(NoteSize 0.08571 StageHeight 0.5))
    Set(LevelMemory *HalfNoteWidth Divide(NoteWidth 2))
    Set(LevelMemory *NoteBaseY1 Subtract(1 Divide(NoteHeight LaneYMultiplier)))
    Set(LevelMemory *NoteBaseY2 Add(1 Divide(NoteHeight LaneYMultiplier)))
    Set(LevelMemory *NoteScreenTime Divide(Subtract(12 NoteSpeed) 2))

    SetShifted(LevelUI *UIMenu *UIAnchorX Subtract(AspectRatio 0.05))
    SetShifted(LevelUI *UIMenu *UIAnchorY 0.95)
    SetShifted(LevelUI *UIMenu *UIPivotX 1)
    SetShifted(LevelUI *UIMenu *UIPivotY 1)
    SetShifted(LevelUI *UIMenu *UIWidth 0.15)
    SetShifted(LevelUI *UIMenu *UIHeight 0.15)
    SetShifted(LevelUI *UIMenu *UIAlpha 1)
    SetShifted(LevelUI *UIMenu *UIBackground true)

    SetShifted(LevelUI *UIJudgment *UIAnchorX 0)
    SetShifted(LevelUI *UIJudgment *UIAnchorY Multiply(StageHeight -0.25))
    SetShifted(LevelUI *UIJudgment *UIPivotX 0.5)
    SetShifted(LevelUI *UIJudgment *UIPivotY 0)
    SetShifted(LevelUI *UIJudgment *UIWidth 0.8)
    SetShifted(LevelUI *UIJudgment *UIHeight 0.2)
    SetShifted(LevelUI *UIJudgment *UIAlpha 1)
    SetShifted(LevelUI *UIJudgment *UIVerticalAlign -1)

    SetShifted(LevelUI *UIComboValue *UIAnchorX Multiply(AspectRatio 0.7))
    SetShifted(LevelUI *UIComboValue *UIAnchorY 0)
    SetShifted(LevelUI *UIComboValue *UIPivotX 0.5)
    SetShifted(LevelUI *UIComboValue *UIPivotY 0)
    SetShifted(LevelUI *UIComboValue *UIWidth 0.5)
    SetShifted(LevelUI *UIComboValue *UIHeight 0.25)
    SetShifted(LevelUI *UIComboValue *UIAlpha 1)
    SetShifted(LevelUI *UIComboValue *UIVerticalAlign -1)

    SetShifted(LevelUI *UIComboText *UIAnchorX Multiply(AspectRatio 0.7))
    SetShifted(LevelUI *UIComboText *UIAnchorY 0)
    SetShifted(LevelUI *UIComboText *UIPivotX 0.5)
    SetShifted(LevelUI *UIComboText *UIPivotY 1)
    SetShifted(LevelUI *UIComboText *UIWidth 0.5)
    SetShifted(LevelUI *UIComboText *UIHeight 0.25)
    SetShifted(LevelUI *UIComboText *UIAlpha 1)
    SetShifted(LevelUI *UIComboText *UIVerticalAlign 1)

    SetShifted(LevelUI *UIScoreBar *UIAnchorX Subtract(0.05 AspectRatio))
    SetShifted(LevelUI *UIScoreBar *UIAnchorY 0.95)
    SetShifted(LevelUI *UIScoreBar *UIPivotX 0)
    SetShifted(LevelUI *UIScoreBar *UIPivotY 1)
    SetShifted(LevelUI *UIScoreBar *UIWidth 0.6)
    SetShifted(LevelUI *UIScoreBar *UIHeight 0.1)
    SetShifted(LevelUI *UIScoreBar *UIAlpha 1)
    SetShifted(LevelUI *UIScoreBar *UIHorizontalAlign -1)
    SetShifted(LevelUI *UIScoreBar *UIBackground true)

    SetShifted(LevelUI *UIScoreValue *UIAnchorX Subtract(0.05 AspectRatio))
    SetShifted(LevelUI *UIScoreValue *UIAnchorY 0.85)
    SetShifted(LevelUI *UIScoreValue *UIPivotX 0)
    SetShifted(LevelUI *UIScoreValue *UIPivotY 1)
    SetShifted(LevelUI *UIScoreValue *UIWidth 0.6)
    SetShifted(LevelUI *UIScoreValue *UIHeight 0.15)
    SetShifted(LevelUI *UIScoreValue *UIAlpha 1)
    SetShifted(LevelUI *UIScoreValue *UIHorizontalAlign -1)

    true
)



// #1: Stage

#1.shouldSpawn:Equal(Get(EntityInfoArray *State) Despawned)

#1.initialize:Execute(
    Set(EntityMemory *JudgeX1 Multiply(-1 AspectRatio))
    Set(EntityMemory *JudgeX2 Multiply(1 AspectRatio))
    Set(EntityMemory *JudgeY1 Subtract(LaneY1 0.02))
    Set(EntityMemory *JudgeY2 Add(LaneY1 0.02))
    Set(EntityMemory *StageBorderBL Multiply(-3.75 LaneWidth))
    Set(EntityMemory *StageBorderBR Multiply(3.75 LaneWidth))
    Set(EntityMemory *StageBorderTL Multiply(0.05 StageBorderBL))
    Set(EntityMemory *StageBorderTR Multiply(0.05 StageBorderBR))

    Set(EntityMemory *Looper 0)
    While(
        Less(Looper 8)
        SetShifted(EntityMemory *LaneBX Looper Multiply(LaneWidth Subtract(Looper 3.5)))
        SetShifted(EntityMemory *LaneTX Looper Multiply(0.05 GetShifted(EntityMemory *LaneBX Looper)))
        Set(EntityMemory *Looper Add(Looper 1))
    )
)

#1.updateSequential:And(
    StageTilt
    Execute(
        Set(LevelTransform 4 Multiply(0.5 Add(Get(LevelTransform 4) Divide(Tilt AspectRatio -10))))
        Set(LevelMemory *Tilt 0)
    )
)

#1.updateParallel:Execute(
    Draw(
        TextureJudgeLine
        JudgeX1 JudgeY1
        JudgeX1 JudgeY2
        JudgeX2 JudgeY2
        JudgeX2 JudgeY1
        LayerJudgeLine
        1
    )
    Draw(
        TextureStageL
        StageBorderBL LaneY1
        StageBorderTL LaneY2
        GetShifted(EntityMemory *LaneTX 0) LaneY2
        GetShifted(EntityMemory *LaneBX 0) LaneY1
        LayerStage
        1
    )
    Draw(
        TextureStageR
        GetShifted(EntityMemory *LaneBX 7) LaneY1
        GetShifted(EntityMemory *LaneTX 7) LaneY2
        StageBorderTR LaneY2
        StageBorderBR LaneY1
        LayerStage
        1
    )

    Set(EntityMemory *Looper 0)
    While(
        Less(Looper 7)
        Draw(
            TextureLane
            GetShifted(EntityMemory *LaneBX Looper) LaneY1
            GetShifted(EntityMemory *LaneTX Looper) LaneY2
            GetShifted(EntityMemory *LaneTX Add(Looper 1)) LaneY2
            GetShifted(EntityMemory *LaneBX Add(Looper 1)) LaneY1
            LayerStage
            1
        )
        Set(EntityMemory *Looper Add(Looper 1))
    )
)

#1.touch@1:Or(
    Auto
    And(
        TempTouchStarted
        IsTouchY
        Execute(
            Set(EntityMemory *Looper 0)
            While(
                Less(Looper 7)
                And(
                    GreaterOr(TempTouchX GetShifted(EntityMemory *LaneBX Looper))
                    LessOr(TempTouchX GetShifted(EntityMemory *LaneBX Add(Looper 1)))
                    Execute(
                        And(
                            Not(TempTouchOccupied)
                            Execute(
                                PlayEmptySound
                                And(
                                    SlotEffect
                                    Spawn(
                                        9
                                        Time
                                        Subtract(Looper 3)
                                    )
                                )
                            )
                        )
                        And(
                            LaneEffect
                            Spawn(
                                11
                                Time
                                GetShifted(EntityMemory *LaneBX Looper)
                                GetShifted(EntityMemory *LaneTX Looper)
                                GetShifted(EntityMemory *LaneTX Add(Looper 1))
                                GetShifted(EntityMemory *LaneBX Add(Looper 1))
                            )
                        )
                    )
                )
                Set(EntityMemory *Looper Add(Looper 1))
            )
        )
    )
)



// #2: Tap Note

#2.shouldSpawn:IsNoteTailOnScreen

#2.initialize:Execute(
    InitNoteTail
    InitSimLine
    InitAutoNormal
)

#2.touch:Or(
    Auto
    And(
        Not(InputState)
        IsNoteTailInGoodWindow
        TempTouchStarted
        Not(TempTouchOccupied)
        IsTouchY
        IsTouchXInTailLane
        Execute(
            Set(TemporaryMemory *TempTouchOccupied true)
            Set(EntityMemory *InputState Terminated)
            Set(EntitySharedMemory *InputSuccess true)
            Set(EntitySharedMemory *InputTouchID TempTouchID)
            Set(EntityInput *Judgment JudgeSimple(Subtract(TempTouchST InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
            Set(EntityInput *Bucket NoteBucket)
            Set(EntityInput *BucketValue Multiply(1000 Subtract(TempTouchST InputOffset NoteTailTime)))
            PlayTapEffect
            PlayJudgmentSound
        )
    )
)

#2.updateParallel:Execute(
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteTail
        )
    )
)



// #3: Flick Note

#3.shouldSpawn:IsNoteTailOnScreen

#3.initialize:Execute(
    InitNoteTail
    InitSimLine
    InitAutoFlick
)

#3.touch:Or(
    Auto
    Execute(
        And(
            Not(InputState)
            IsNoteTailInGoodWindow
            TempTouchStarted
            Not(TempTouchOccupied)
            IsTouchY
            IsTouchXInTailLane
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(EntityMemory *InputState Activated)
                Set(EntityMemory *ActivationTime TempTouchST)
                Set(EntitySharedMemory *InputTouchID TempTouchID)
            )
        )
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                And(
                    IsNoteTailInGoodWindow
                    GreaterOr(TempTouchVR MinVR)
                    Execute(
                        Set(EntityMemory *InputState Terminated)
                        Set(EntitySharedMemory *InputSuccess true)
                        Set(EntityInput *Judgment JudgeSimple(Subtract(ActivationTime InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                        Set(EntityInput *Bucket NoteBucket)
                        Set(EntityInput *BucketValue Multiply(1000 Subtract(ActivationTime InputOffset NoteTailTime)))
                        PlayFlickEffect
                        PlayFlickSound
                    )
                )
                ProcessFlickDiscontinue
            )
        )
    )
)

#3.updateParallel:Execute(
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoFlickEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteTail
            DrawNoteTailArrow
        )
    )
)



// #4: Slide Touch Note

#4.shouldSpawn:IsNoteHeadOnScreen

#4.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitAutoNormal
)

#4.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(LevelMemory *Tilt Add(Tilt TempTouchX))
                And(
                    GreaterOr(Subtract(Time InputOffset) NoteTailTime)
                    IsTouchY
                    IsTouchXInTailLane
                    Execute(
                        Set(EntityMemory *InputState Terminated)
                        Set(EntitySharedMemory *InputSuccess true)
                        Set(EntityInput *Judgment JudgeSimple(Subtract(Time InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                        Set(EntityInput *Bucket NoteBucket)
                        Set(EntityInput *BucketValue Multiply(1000 Subtract(Time InputOffset NoteTailTime)))
                        PlayTapEffect
                        PlayJudgmentSound
                    )
                )
                ProcessTouchDiscontinue
            )
        )
    )
)

#4.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                DrawNoteTail
            )
        )
    )
)



// #5: Slide Release Note

#5.shouldSpawn:IsNoteHeadOnScreen

#5.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitSimLine
    InitAutoNormal
)

#5.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(LevelMemory *Tilt Add(Tilt TempTouchX))
                And(
                    IsNoteTailInGoodWindow
                    TempTouchEnded
                    IsTouchY
                    IsTouchXInTailLane
                    Execute(
                        Set(EntityMemory *InputState Terminated)
                        Set(EntitySharedMemory *InputSuccess true)
                        Set(EntityInput *Judgment JudgeSimple(Subtract(TempTouchT InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                        Set(EntityInput *Bucket NoteBucket)
                        Set(EntityInput *BucketValue Multiply(1000 Subtract(TempTouchT InputOffset NoteTailTime)))
                        PlayTapEffect
                        PlayJudgmentSound
                    )
                )
                ProcessTouchDiscontinue
            )
        )
    )
)

#5.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                DrawNoteTail
            )
        )
    )
)



// #6: Slide Flick Note

#6.shouldSpawn:IsNoteHeadOnScreen

#6.initialize:Execute(
    InitNoteHead
    InitNoteTail
    InitSimLine
    InitAutoFlick
)

#6.touch:Or(
    Auto
    Execute(
        ProcessTouchHead
        And(
            InputState
            NotEqual(InputState Terminated)
            Equal(TempTouchID InputTouchID)
            Execute(
                Set(TemporaryMemory *TempTouchOccupied true)
                Set(LevelMemory *Tilt Add(Tilt TempTouchX))
                And(
                    Equal(InputState Activated)
                    GreaterOr(Subtract(Time InputOffset) NoteTailTime)
                    IsTouchY
                    IsTouchXInTailLane
                    Set(EntityMemory *InputState ActivatedNext)
                )
                And(
                    Equal(InputState ActivatedNext)
                    GreaterOr(TempTouchVR MinVR)
                    Execute(
                        Set(EntityMemory *InputState Terminated)
                        Set(EntitySharedMemory *InputSuccess true)
                        Set(EntityInput *Judgment JudgeSimple(Subtract(Time InputOffset) NoteTailTime PerfectWindow GreatWindow GoodWindow))
                        Set(EntityInput *Bucket NoteBucket)
                        Set(EntityInput *BucketValue Multiply(1000 Subtract(Time InputOffset NoteTailTime)))
                        PlayFlickEffect
                        PlayFlickSound
                    )
                )
                ProcessFlickDiscontinue
            )
        )
    )
)

#6.updateParallel:Execute(
    UpdateNoteHeadTimeDistance
    UpdateNoteTailTimeDistance
    Or(
        And(
            Auto
            GreaterOr(Time NoteTailTime)
            Execute(
                PlayAutoTapEffect
                true
            )
        )
        Equal(InputState Terminated)
        Greater(Subtract(NoteTailTimeDistance InputOffset) GoodWindow)
        Execute(
            UpdateNoteTailScale
            DrawNoteSlide
            And(
                IsNoteTailOnScreen
                Execute(
                    DrawNoteTail
                    DrawNoteTailArrow
                )
            )
        )
    )
)



// #7: Tap Effect

#7.initialize:Execute(
    Set(EntityMemory *EffectLX1 Subtract(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLX2 Subtract(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX3 Add(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX4 Add(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLY1 Add(LaneY1 Multiply(3 HalfNoteWidth)))
)

#7.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            DrawEffectC
            DrawEffectL
        )
    )
)



// #8: Flick Effect

#8.initialize:Execute(
    Set(EntityMemory *EffectLX1 Subtract(EffectX Multiply(0.5 HalfNoteWidth)))
    Set(EntityMemory *EffectLX2 Subtract(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX3 Add(EffectX Multiply(0.75 HalfNoteWidth)))
    Set(EntityMemory *EffectLX4 Add(EffectX Multiply(0.5 HalfNoteWidth)))
)

#8.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            DrawEffectC
            DrawEffectLF

            And(
                Less(EffectTimeDistance 0.2)
                Execute(
                    Set(EntityMemory *EffectAlpha 0.5)
                    Set(
                        EntityMemory *HalfEffectWidth
                        Multiply(HalfNoteWidth 1.5 Subtract(0.2 EffectTimeDistance) 5)
                    )
                    Set(
                        EntityMemory *HalfEffectHeight
                        Multiply(HalfNoteWidth 2 Add(0.4 EffectTimeDistance) 5)
                    )
                    UpdateEffectPosition
                    DrawEffectCB
                )
            )
        )
    )
)



// #9: Empty Tap Effect

#9.initialize:Execute(
    Set(EntityMemory *EffectLX1 Multiply(Subtract(EffectX 0.5) LaneWidth))
    Set(EntityMemory *EffectLX3 Multiply(Add(EffectX 0.5) LaneWidth))
    Set(EntityMemory *EffectLY1 Add(LaneY1 Multiply(0.5 LaneWidth)))
)

#9.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.6)
        Execute(
            Set(EntityMemory *EffectAlpha Divide(Subtract(1 EaseInOutCubic(Divide(EffectTimeDistance 0.6))) 2))
            Set(EntityMemory *EffectLY2 Add(LaneY1 Multiply(LaneWidth EaseOutCubic(Divide(EffectTimeDistance 0.6)))))

            Draw(
                TextureEffectLF
                EffectLX1 LaneY1
                EffectLX1 EffectLY2
                EffectLX3 EffectLY2
                EffectLX3 LaneY1
                LayerEffectLF
                EffectAlpha
            )

            Draw(
                TextureEffectLB
                EffectLX1 LaneY1
                EffectLX1 EffectLY1
                EffectLX3 EffectLY1
                EffectLX3 LaneY1
                LayerEffectLB
                EffectAlpha
            )
        )
    )
)



// #10: Sim Line

#10.initialize:Execute(
    Set(EntityMemory *SimLineTime SimLineTime1)
    Set(EntityMemory *SimLineX1 Multiply(SimLineLane1 LaneWidth))
    Set(EntityMemory *SimLineX2 Multiply(SimLineLane2 LaneWidth))
)

#10.updateParallel:Or(
    And(
        Auto
        GreaterOr(Time SimLineTime)
    )
    Equal(SimLineState1 Despawned)
    Equal(SimLineState2 Despawned)
    And(
        LessOr(Subtract(SimLineTime Time) NoteScreenTime)
        Execute(
            Set(EntityMemory *SimLineTimeDistance Subtract(Time SimLineTime))
            Set(EntityMemory *SimLineScale Add(0.05 Multiply(0.95 Power(117.39085 Divide(SimLineTimeDistance NoteScreenTime)))))
            Set(EntityMemory *SimLineScale1 Multiply(NoteBaseY1 SimLineScale))
            Set(EntityMemory *SimLineScale2 Multiply(NoteBaseY2 SimLineScale))
            Set(EntityMemory *SimLineY1 Add(LaneYOffset Multiply(LaneYMultiplier SimLineScale1)))
            Set(EntityMemory *SimLineY2 Add(LaneYOffset Multiply(LaneYMultiplier SimLineScale2)))
            Draw(
                TextureSimLine
                Multiply(SimLineScale1 SimLineX1) SimLineY1
                Multiply(SimLineScale2 SimLineX1) SimLineY2
                Multiply(SimLineScale2 SimLineX2) SimLineY2
                Multiply(SimLineScale1 SimLineX2) SimLineY1
                LayerSimLine
                1
            )
        )
    )
)



// #11: Lane Effect

#11.updateParallel:Execute(
    UpdateEffectTimeDistance
    Or(
        GreaterOr(EffectTimeDistance 0.2)
        Draw(
            TextureEffectLB
            LaneEffectX1 LaneY1
            LaneEffectX2 LaneY2
            LaneEffectX3 LaneY2
            LaneEffectX4 LaneY1
            LayerLaneEffect
            Subtract(1 Divide(EffectTimeDistance 0.2))
        )
    )
)



// Constants

true:1
false:0

Waiting:0
Spawned:1
Despawned:2

Waiting:0
Activated:1
ActivatedNext:2
Terminated:3

PhaseBegan:1
PhaseStationary:2
PhaseMoved:3
PhaseEnded:4

PerfectWindow:0.05
GreatWindow:0.1
GoodWindow:0.15

JudgeYMax:0
MinVR:1.5

MinEffectTime:0.02

LayerNoteMarker:101
LayerNoteBody:100
LayerNoteSlide:99
LayerNoteConnector:98
LayerSimLine:97
LayerEffectLF:53
LayerEffectCF:52
LayerEffectLB:51
LayerEffectCB:50
LayerJudgeLine:2
LayerLaneEffect:1
LayerStage:0

JudgmentMiss:0
JudgmentPerfect:1
JudgmentGreat:2
JudgmentGood:3



// Texture identifiers

TextureJudgeLine:41000
TextureLane:40100
TextureSimLine:12006
TextureSlide:1002
TextureLong:11002
TextureArrow:21001
TextureEffectLB:33000
TextureEffectLF:34000
TextureStageL:40001
TextureStageR:40002



// Effect identifiers

EffectMiss:0
EffectPerfect:1
EffectGreat:2
EffectGood:3
EffectFlick:4
EffectEmpty:5



// Block identifiers

LevelMemory:0
LevelData:1
LevelOption:2
LevelTransform:3
LevelBackground:4
LevelUI:5

EntityInfoArray:10
EntityDataArray:11
EntitySharedMemoryArray:12

EntityInfo:20
EntityMemory:21
EntityData:22
EntityInput:23
EntitySharedMemory:24

TemporaryMemory:100
TemporaryData:101



// Level Memory Layout

*StageWidth:0
*StageHeight:1
*LaneWidth:2
*LaneYOffset:3
*LaneYMultiplier:4
*LaneY1:5
*LaneY2:6
*NoteWidth:7
*NoteHeight:8
*HalfNoteWidth:9
*NoteBaseY1:10
*NoteBaseY2:11
*NoteScreenTime:12
*Tilt:13

StageWidth:Get(LevelMemory *StageWidth)
StageHeight:Get(LevelMemory *StageHeight)
LaneWidth:Get(LevelMemory *LaneWidth)
LaneYOffset:Get(LevelMemory *LaneYOffset)
LaneYMultiplier:Get(LevelMemory *LaneYMultiplier)
LaneY1:Get(LevelMemory *LaneY1)
LaneY2:Get(LevelMemory *LaneY2)
NoteWidth:Get(LevelMemory *NoteWidth)
NoteHeight:Get(LevelMemory *NoteHeight)
HalfNoteWidth:Get(LevelMemory *HalfNoteWidth)
NoteBaseY1:Get(LevelMemory *NoteBaseY1)
NoteBaseY2:Get(LevelMemory *NoteBaseY2)
NoteScreenTime:Get(LevelMemory *NoteScreenTime)
Tilt:Get(LevelMemory *Tilt)



// Level Data Layout

*Time:0
*DeltaTime:1
*AspectRatio:2
*AudioOffset:3
*InputOffset:4

Time:Get(LevelData *Time)
DeltaTime:Get(LevelData *DeltaTime)
AspectRatio:Get(LevelData *AspectRatio)
AudioOffset:Get(LevelData *AudioOffset)
InputOffset:Get(LevelData *InputOffset)



// Level Option Layout

*Auto:0
*Offset:1
*Speed:2
*NoteSpeed:3
*NoteSize:4
*ConnectorAlpha:5
*Mirror:6
*SimLine:7
*SoundEffect:8
*NoteEffect:9
*LaneEffect:10
*SlotEffect:11
*StageTilt:12
*StageAspectRatioLock:13

Auto:Get(LevelOption *Auto)
Offset:Get(LevelOption *Offset)
Speed:Get(LevelOption *Speed)
NoteSpeed:Get(LevelOption *NoteSpeed)
NoteSize:Get(LevelOption *NoteSize)
ConnectorAlpha:Get(LevelOption *ConnectorAlpha)
Mirror:Get(LevelOption *Mirror)
SimLine:Get(LevelOption *SimLine)
SoundEffect:Get(LevelOption *SoundEffect)
NoteEffect:Get(LevelOption *NoteEffect)
LaneEffect:Get(LevelOption *LaneEffect)
SlotEffect:Get(LevelOption *SlotEffect)
StageTilt:Get(LevelOption *StageTilt)
StageAspectRatioLock:Get(LevelOption *StageAspectRatioLock)



// Level UI Layout

*UIMenu:0
*UIJudgment:11
*UIComboValue:22
*UIComboText:33
*UIScoreBar:44
*UIScoreValue:55

*UIAnchorX:0
*UIAnchorY:1
*UIPivotX:2
*UIPivotY:3
*UIWidth:4
*UIHeight:5
*UIRotation:6
*UIAlpha:7
*UIHorizontalAlign:8
*UIVerticalAlign:9
*UIBackground:10



// Entity Info Layout

*Index:0
*Archetype:1
*State:2

Index:Get(EntityInfo *Index)
Archetype:Get(EntityInfo *Archetype)
State:Get(EntityInfo *State)

NoteHeadState:GetShifted(EntityInfoArray NoteHeadInfoOffset *State)

SimLineState1:GetShifted(EntityInfoArray SimLineInfoOffset1 *State)
SimLineState2:GetShifted(EntityInfoArray SimLineInfoOffset2 *State)



// Entity Input Layout

*Judgment:0
*Bucket:1
*BucketValue:2

Judgment:Get(EntityInput *Judgment)
Bucket:Get(EntityInput *Bucket)
BucketValue:Get(EntityInput *BucketValue)



// Touch Temporary Memory Layout

*TempTouchOccupied:0

TempTouchOccupied:Get(TemporaryMemory *TempTouchOccupied)


// Touch Temporary Data Layout

*TempTouchID:0
*TempTouchStarted:1
*TempTouchEnded:2
*TempTouchT:3
*TempTouchST:4
*TempTouchX:5
*TempTouchY:6
*TempTouchSX:7
*TempTouchSY:8
*TempTouchDX:9
*TempTouchDY:10
*TempTouchVX:11
*TempTouchVY:12
*TempTouchVR:13
*TempTouchVW:14

TempTouchID:Get(TemporaryData *TempTouchID)
TempTouchStarted:Get(TemporaryData *TempTouchStarted)
TempTouchEnded:Get(TemporaryData *TempTouchEnded)
TempTouchT:Get(TemporaryData *TempTouchT)
TempTouchST:Get(TemporaryData *TempTouchST)
TempTouchX:Get(TemporaryData *TempTouchX)
TempTouchY:Get(TemporaryData *TempTouchY)
TempTouchSX:Get(TemporaryData *TempTouchSX)
TempTouchSY:Get(TemporaryData *TempTouchSY)
TempTouchDX:Get(TemporaryData *TempTouchDX)
TempTouchDY:Get(TemporaryData *TempTouchDY)
TempTouchVX:Get(TemporaryData *TempTouchVX)
TempTouchVY:Get(TemporaryData *TempTouchVY)
TempTouchVR:Get(TemporaryData *TempTouchVR)
TempTouchVW:Get(TemporaryData *TempTouchVW)



// #1 Memory Layout

*JudgeX1:0
*JudgeX2:1
*JudgeY1:2
*JudgeY2:3
*StageBorderBL:4
*StageBorderBR:5
*StageBorderTL:6
*StageBorderTR:7
*LaneBX:8
*LaneTX:16
*Looper:63

JudgeX1:Get(EntityMemory *JudgeX1)
JudgeX2:Get(EntityMemory *JudgeX2)
JudgeY1:Get(EntityMemory *JudgeY1)
JudgeY2:Get(EntityMemory *JudgeY2)
StageBorderBL:Get(EntityMemory *StageBorderBL)
StageBorderTL:Get(EntityMemory *StageBorderTL)
StageBorderBR:Get(EntityMemory *StageBorderBR)
StageBorderTR:Get(EntityMemory *StageBorderTR)
Looper:Get(EntityMemory *Looper)



// Note Class Memory Layout

*InputState:32
*ActivationTime:33
*NoteHeadTimeDistance:34
*NoteHeadScale:35
*NoteHeadX:36
*NoteHeadX1:37
*NoteHeadX2:38
*NoteHeadY:39
*NoteTailTimeDistance:40
*NoteTailScale:41
*NoteTailScale1:42
*NoteTailScale2:43
*NoteTailX:44
*NoteTailX1:45
*NoteTailX2:46
*NoteTailY:47
*NoteTailY1:48
*NoteTailY2:49

InputState:Get(EntityMemory *InputState)
ActivationTime:Get(EntityMemory *ActivationTime)
NoteHeadTimeDistance:Get(EntityMemory *NoteHeadTimeDistance)
NoteHeadScale:Get(EntityMemory *NoteHeadScale)
NoteHeadX:Get(EntityMemory *NoteHeadX)
NoteHeadX1:Get(EntityMemory *NoteHeadX1)
NoteHeadX2:Get(EntityMemory *NoteHeadX2)
NoteHeadY:Get(EntityMemory *NoteHeadY)
NoteTailTimeDistance:Get(EntityMemory *NoteTailTimeDistance)
NoteTailScale:Get(EntityMemory *NoteTailScale)
NoteTailScale1:Get(EntityMemory *NoteTailScale1)
NoteTailScale2:Get(EntityMemory *NoteTailScale2)
NoteTailX:Get(EntityMemory *NoteTailX)
NoteTailX1:Get(EntityMemory *NoteTailX1)
NoteTailX2:Get(EntityMemory *NoteTailX2)
NoteTailY:Get(EntityMemory *NoteTailY)
NoteTailY1:Get(EntityMemory *NoteTailY1)
NoteTailY2:Get(EntityMemory *NoteTailY2)



// Note Class Shared Memory Layout

*InputSuccess:0
*InputTouchID:1

InputSuccess:Get(EntitySharedMemory *InputSuccess)
InputTouchID:Get(EntitySharedMemory *InputTouchID)

NoteHeadInputSuccess:GetShifted(EntitySharedMemoryArray NoteHeadSharedMemoryOffset *InputSuccess)
NoteHeadInputTouchID:GetShifted(EntitySharedMemoryArray NoteHeadSharedMemoryOffset *InputTouchID)



// Note Class Data Layout

*NoteHeadIndex:0
*NoteTailTime:1
*NoteTailLane:2
*NoteSimLineIndex:3
*NoteBucket:4
*NoteTexture:5
*NoteEffectCB:6
*NoteEffectCF:7
*NoteEffectLB:8
*NoteEffectLF:9

NoteHeadIndex:Get(EntityData *NoteHeadIndex)
NoteTailTime:Divide(Add(Get(EntityData *NoteTailTime) Divide(Offset 1000)) Speed)
NoteTailLane:Multiply(Get(EntityData *NoteTailLane) If(Mirror -1 1))
NoteSimLineIndex:Get(EntityData *NoteSimLineIndex)
NoteBucket:Get(EntityData *NoteBucket)
NoteTexture:Get(EntityData *NoteTexture)
NoteEffectCB:Get(EntityData *NoteEffectCB)
NoteEffectCF:Get(EntityData *NoteEffectCF)
NoteEffectLB:Get(EntityData *NoteEffectLB)
NoteEffectLF:Get(EntityData *NoteEffectLF)

NoteHeadInfoOffset:Multiply(NoteHeadIndex 3)
NoteHeadDataOffset:Multiply(NoteHeadIndex 32)
NoteHeadSharedMemoryOffset:Multiply(NoteHeadIndex 32)

NoteHeadTime:Divide(Add(GetShifted(EntityDataArray NoteHeadDataOffset *NoteTailTime) Divide(Offset 1000)) Speed)
NoteHeadLane:Multiply(GetShifted(EntityDataArray NoteHeadDataOffset *NoteTailLane) If(Mirror -1 1))

SimLineTime1:Divide(Add(GetShifted(EntityDataArray SimLineDataOffset1 *NoteTailTime) Divide(Offset 1000)) Speed)
SimLineTime2:Divide(Add(GetShifted(EntityDataArray SimLineDataOffset2 *NoteTailTime) Divide(Offset 1000)) Speed)
SimLineLane1:Multiply(GetShifted(EntityDataArray SimLineDataOffset1 *NoteTailLane) If(Mirror -1 1))
SimLineLane2:Multiply(GetShifted(EntityDataArray SimLineDataOffset2 *NoteTailLane) If(Mirror -1 1))



// Effect Class Memory Layout

*EffectTimeDistance:32
*EffectLX1:33
*EffectLX2:34
*EffectLX3:35
*EffectLX4:36
*EffectLY1:37
*EffectLY2:38
*HalfEffectWidth:39
*HalfEffectHeight:40
*EffectAlpha:41
*EffectCX1:42
*EffectCX2:43
*EffectCY1:44
*EffectCY2:45

EffectTimeDistance:Get(EntityMemory *EffectTimeDistance)
EffectLX1:Get(EntityMemory *EffectLX1)
EffectLX2:Get(EntityMemory *EffectLX2)
EffectLX3:Get(EntityMemory *EffectLX3)
EffectLX4:Get(EntityMemory *EffectLX4)
EffectLY1:Get(EntityMemory *EffectLY1)
EffectLY2:Get(EntityMemory *EffectLY2)
HalfEffectWidth:Get(EntityMemory *HalfEffectWidth)
HalfEffectHeight:Get(EntityMemory *HalfEffectHeight)
EffectAlpha:Get(EntityMemory *EffectAlpha)
EffectCX1:Get(EntityMemory *EffectCX1)
EffectCX2:Get(EntityMemory *EffectCX2)
EffectCY1:Get(EntityMemory *EffectCY1)
EffectCY2:Get(EntityMemory *EffectCY2)



// #7, #8, #11 Memory Layout

*EffectTime:0
*EffectX:1
*EffectCB:2
*EffectCF:3
*EffectLB:4
*EffectLF:5

EffectTime:Get(EntityMemory *EffectTime)
EffectX:Get(EntityMemory *EffectX)
EffectCB:Get(EntityMemory *EffectCB)
EffectCF:Get(EntityMemory *EffectCF)
EffectLB:Get(EntityMemory *EffectLB)
EffectLF:Get(EntityMemory *EffectLF)



// #10 Memory Layout

*SimLineIndex1:0
*SimLineIndex2:1
*SimLineTime:2
*SimLineX1:3
*SimLineX2:4
*SimLineTimeDistance:5
*SimLineScale:6
*SimLineScale1:7
*SimLineScale2:8
*SimLineY1:9
*SimLineY2:10

SimLineIndex1:Get(EntityMemory *SimLineIndex1)
SimLineIndex2:Get(EntityMemory *SimLineIndex2)
SimLineTime:Get(EntityMemory *SimLineTime)
SimLineX1:Get(EntityMemory *SimLineX1)
SimLineX2:Get(EntityMemory *SimLineX2)
SimLineTimeDistance:Get(EntityMemory *SimLineTimeDistance)
SimLineScale:Get(EntityMemory *SimLineScale)
SimLineScale1:Get(EntityMemory *SimLineScale1)
SimLineScale2:Get(EntityMemory *SimLineScale2)
SimLineY1:Get(EntityMemory *SimLineY1)
SimLineY2:Get(EntityMemory *SimLineY2)

SimLineInfoOffset1:Multiply(SimLineIndex1 3)
SimLineInfoOffset2:Multiply(SimLineIndex2 3)
SimLineDataOffset1:Multiply(SimLineIndex1 32)
SimLineDataOffset2:Multiply(SimLineIndex2 32)



// #11 Memory Layout

*LaneEffectX1:1
*LaneEffectX2:2
*LaneEffectX3:3
*LaneEffectX4:4

LaneEffectX1:Get(EntityMemory *LaneEffectX1)
LaneEffectX2:Get(EntityMemory *LaneEffectX2)
LaneEffectX3:Get(EntityMemory *LaneEffectX3)
LaneEffectX4:Get(EntityMemory *LaneEffectX4)
